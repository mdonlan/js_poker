{
  "version": 3,
  "sources": ["../src/types.ts", "../src/Log.ts", "../src/UI.tsx", "../src/Game.ts", "../src/Deck.ts", "../src/Sim_Hand.ts", "../src/ai.ts", "../src/compare_hands.ts", "../src/index.ts"],
  "sourcesContent": ["\nexport enum Suit {\n\tHEARTS,\n\tSPADES,\n\tCLUBS,\n\tDIAMONDS\n}\n\nexport interface Card {\n\tvalue: Card_Type;\n\tsuit: Suit;\n\tid: number;\n}\n\nexport interface Card_Info {\n\tsuit: Suit;\n\ttype: Card_Type;\n}\n\nexport interface Cards_By_Suit {\n\thearts: Card[];\n\tspades: Card[];\n\tclubs: Card[];\n\tdiamonds: Card[];\n}\n\nexport enum Player_Type {\n\tAI,\n\tHUMAN\n}\n\nexport interface Player {\n\tid: number; // formally -> 'num'\n\thand: Card[];\n\tmoney: number;\n\tname: string;\n\ttype: Player_Type;\n\t// round_bet: number;\n\thand_rank: Hand_Rank;\n\tfinal_hand_cards: Card[]; // all cards this player could use in their final hand, including community cards\n\tbest_cards: Card[]; // the five cards used out of the seven\n\thighest_value_in_hand: number;\n\tamount_bet_this_round: number;\n\thas_folded: boolean;\n}\n\nexport interface Ranked_Hand {\n\trank: Hand_Rank;\n\tplayer: Player;\n\thighest_value_in_hand: number;\n\thand: Card[];\n}\n\nexport interface Hand_Results {\n\twinners: Player[];\n}\n\nexport interface Sim_Result {\n\twins: number;\n\trun_count: number;\n}\n\nexport enum Hand_Rank {\n\tHIGH_CARD,\n\tPAIR,\n\tTWO_PAIR,\n\tTHREE_OF_KIND,\n\tSTRAIGHT,\n\tFLUSH,\n\tFULL_HOUSE,\n\tFOUR_OF_KIND,\n\tSTRAIGHT_FLUSH,\n\tROYAL_FLUSH,\n\tUNRANKED\n}\n\nexport enum Card_Type {\n    TWO = 2,\n    THREE,\n    FOUR,\n    FIVE,\n    SIX,\n    SEVEN,\n    EIGHT,\n    NINE,\n    TEN,\n    JACK,\n    QUEEN,\n    KING,\n    ACE\n}\n\nexport enum Hand_Phase {\n\tPREFLOP,\n\tFLOP,\n\tTURN,\n\tRIVER,\n\tSHOWDOWN\n}\n\nexport interface Blinds {\n\tsmall: number;\n\tbig: number;\n}\n\nexport interface Current_Hand {\n\tpot: number;\n\tcurrent_bet: number;\n\ttemp_player_bet: number;\n}", "interface Log {\n    // items: [];\n    print: boolean;\n};\n\nexport let log: Log = {\n    // items: []\n    print: true\n};\n\nconst log_messages_elem = document.querySelector(\".log_messages\");\n\nexport function add_log_msg(message: string) {\n    // if (log.print) {\n    //     console.log(message);\n    // }\n\n    // log_messages_elem.innerHTML += `<div>${message}</div>`\n}", "export function el(query: string) {\n\treturn document.querySelector(query);\n}\n\nexport function child_el(target: Element, query: string) {\n\treturn target.querySelector(query);\n}", "import { Card, Player, Hand_Phase, Player_Type, Hand_Rank } from \"./types\";\n\nexport interface Game {\n\tdeck: Card[];\n\tcommunity_cards: Card[];\n\tplayers: Player[];\n\thuman_player: Player | null;\n\thand_phase: Hand_Phase;\n\tround_current_player_index: number;\n\tactive_player: Player | null;\n\tround_order: Player[];\n\thand_winners: Player[];\n\tblinds: Blinds;\n\tcurrent_hand: Current_Hand;\n\tis_sim_game: boolean;\n\tdev_do_next_turn: boolean;\n}\n\nexport const game: Game = {\n\tdeck: [],\n\tcommunity_cards: [],\n\tplayers: [],\n\thand_phase: Hand_Phase.PREFLOP,\n\tround_current_player_index: 0,\n\t// round_start_player_index: 0,\n\tround_order: [],\n\tactive_player: null,\n\thand_winners: [],\n\t// dealer_index: 0,\n\tblinds: {small: 5, big: 10},\n\tcurrent_hand: {pot: 0, current_bet: 0, temp_player_bet: 0},\n\thuman_player: null,\n\tis_sim_game: false,\n\tdev_do_next_turn: false\n};\n\nexport function create_player(id: number, type: Player_Type): Player {\n\tlet player: Player = {\n\t\tid: id,\n\t\thand: [],\n\t\tmoney: 1000,\n\t\tname: \"player\" + id,\n\t\ttype: type,\n\t\t// round_bet: 0,\n\t\thand_rank: Hand_Rank.UNRANKED,\n\t\tfinal_hand_cards: [],\n\t\tbest_cards: [],\n\t\thighest_value_in_hand: 0,\n\t\tamount_bet_this_round: 0,\n\t\thas_folded: false\n\t}\n\n\treturn player;\n}\n\nexport function create_players(): Player[] {\n\tlet num_players: number = 6;\n\tlet players: Player[] = [];\n\tfor (let i = 0; i < num_players; i++) {\n\t\tlet type = Player_Type.AI;\n\n\t\tif (i == 0) type = Player_Type.HUMAN;\n\n\t\tlet player: Player = create_player(i, type);\n\t\tplayers.push(player);\n\t}\n\n\treturn players;\n};", "import { Card, Suit } from \"./types\";\nimport { game } from \"./Game\";\nimport { add_log_msg } from \"./Log\";\nimport { Hand_Phase, Hand_Rank, } from \"./types\";\nimport { updateCommunityCardElems, create_round_order, deal_cards, clear_final_hand, blinds, update_player_ui, start_betting_round} from \".\";\nimport { el } from \"./UI\";\n\nexport function create_deck(): Card[] {\n\tlet new_deck: Card[] = [];\n\tlet card_value: number = 2; // the value of the card. from 2-14\n\tlet current_suit: number = 0;\n\tlet cards_in_suit: number = 0;\n\n\tfor (let i = 0; i < 52; i++) {\n\t\tlet card: Card = {\n\t\t\tvalue: card_value,\n\t\t\tsuit: <Suit>current_suit,\n\t\t\tid: i,\n\t\t}\n\t\tnew_deck.push(card);\n\n\t\tcard_value++;\n\t\tif (card_value == 15) {\n\t\t\tcard_value = 2;\n\t\t}\n\n\t\tcards_in_suit++;\n\t\tif (cards_in_suit == 13) {\n\t\t\tcurrent_suit++;\n\t\t\tcards_in_suit = 0;\n\t\t}\n\t}\n\n\treturn new_deck;\n};\n\nexport function deal_new_hand() {\n\tadd_log_msg(\"Dealing new hand\");\n\t\n\tgame.deck = create_deck();\n\tgame.hand_winners = [];\n\tgame.community_cards = [];\n\tgame.current_hand.pot = 0;\n\tgame.hand_phase = Hand_Phase.PREFLOP;\n\t\n\tupdateCommunityCardElems();\n\n\tcreate_round_order(0);\n\n\tconst dealer = game.round_order[game.round_order.length - 3];\n\tconst small_blind = game.round_order[game.round_order.length - 2];\n\tconst big_blind = game.round_order[game.round_order.length - 1];\n\tconst first_to_bet = game.round_order[0];\n\n\tadd_log_msg(\"Dealer is \" + dealer.name);\n\tadd_log_msg(`Small blind is $${game.blinds.small} to ${small_blind.name}`);\n\tadd_log_msg(`Big blind is $${game.blinds.big} to ${big_blind.name}`);\n\n\t// reset each player\n\tgame.players.forEach(player => {\n\t\tplayer.hand = <Card[]>[];\n\t\tplayer.final_hand_cards = <Card[]>[];\n\t\tplayer.hand_rank = Hand_Rank.UNRANKED;\n\t\tplayer.amount_bet_this_round = 0;\n\t\tplayer.best_cards = [];\n\t\tplayer.highest_value_in_hand = 0;\n\t\tplayer.has_folded = false;\n\t\tdeal_cards(player, 2);\n\n\t\tclear_final_hand(player);\n\t});\n\t\n\tel(\".end_of_hand\").classList.add(\"end_of_hand_hide\");\n\n\tblinds();\n\n\tupdate_player_ui();\n\tstart_betting_round();\n};", "// this class handles simulating a hand\n// each time an ai tries to decide if it should stay in the hand\n// or fold they will call a new SimulateHand and pass in their cards, and any avaliable community cards\n// then they will sim the hand x times too see the outcomes\n\nimport { Game } from \"./Game\";\nimport { find_hand_winner } from \".\";\nimport { create_deck } from \"./Deck\";\nimport { Card, Player, Sim_Result } from \"./types\";\n\nexport class Sim_Hand { \n\t// public hand: Card[];\n\t// public comCards: Card[];\n\t// public players: Player[];\n\t// public player: Player;\n\t// public deck: Card[];\n\tpublic game: Game;\n\tpublic base_game_copy: Game; // don't change the data in here, we use to reset the sim\n\tpublic player: Player;\n\tpublic base_player_copy: Player;\n\n\tpublic run_count: number = 0; \n\tpublic wins: number = 0;\n\n\tpublic results: Sim_Result;\n\n\tconstructor(game: Game, player: Player) {\n\t\tthis.game = JSON.parse(JSON.stringify(game));\n\t\tthis.game.is_sim_game = true;\n\n\t\tthis.base_game_copy = JSON.parse(JSON.stringify(this.game));\n\n\t\tthis.player = JSON.parse(JSON.stringify(player));\n\t\tthis.base_player_copy = JSON.parse(JSON.stringify(player));\n\n\t\tthis.startSim();\n\n\t\tthis.results = {\n\t\t\twins: this.wins,\n\t\t\trun_count: this.run_count\n\t\t}\n\t}\n\n\tstartSim() {\n\t\t// start a new simulation of a hand\n\t\tfor (let i = 0; i < 100; i++) {\n\t\t\tthis.set_deck();\n\t\t\tthis.deal_rest_of_com_cards();\n\t\t\tthis.deal_other_players();\n\t\t\t// this.deal_rest_of_hand();\n\t\t\tthis.get_winner();\n\t\t\tthis.reset();\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.game = JSON.parse(JSON.stringify(this.base_game_copy));\n\t\tthis.player = JSON.parse(JSON.stringify(this.base_player_copy));\n\t}\n\n\tset_deck() {\n\t\t// set the deck to have all cards, except for the cards the current ai has and the comCards\n\t\tthis.game.deck = create_deck();\n\t\tlet usedCards = this.player.hand.concat(this.game.community_cards);\n\t\t// let used = this.player.hand;\n\n\t\tlet sortedDeck = [];\n\t\tfor (let i = 0; i < this.game.deck.length; i++) {\n\t\t\tlet card = this.game.deck[i];\n\t\t\tlet matched = false;\n\t\t\tfor (let j = 0; j < usedCards.length; j++) {\n\t\t\t\tlet usedCard = usedCards[j];\n\n\t\t\t\tif (card.id == usedCard.id) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tsortedDeck.push(card);\n\t\t\t}\n\t\t}\n\t\tthis.game.deck = sortedDeck;\n\t};\n\n\tdeal_rest_of_com_cards() {\n\t\t// deal out the rest of the community cards \n\n\t\twhile (this.game.community_cards.length < 5) {\n\t\t\t//log(\"dealing new com card\");\n\t\t\tlet index = Math.floor(Math.random() * this.game.deck.length);\n\t\t\tlet card = this.game.deck[index];\n\t\t\tthis.game.community_cards.push(card);\n\t\t\tthis.game.deck.splice(index, 1);\n\t\t}\n\t};\n\n\tdeal_other_players() {\n\t\t// deal all the other players random cards\n\t\t// first reset their hands\n\n\t\tthis.game.players.forEach((player) => {\n\t\t\tif (player.id != this.player.id) {\n\t\t\t\tplayer.hand = [];\n\n\t\t\t\twhile (player.hand.length < 2) {\n\t\t\t\t\tplayer.hand.push(this.deal_card());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tdeal_card() {\n\t\tlet index = Math.floor(Math.random() * this.game.deck.length);\n\t\tlet card = this.game.deck[index];\n\t\tthis.game.deck.splice(index, 1);\n\t\treturn card;\n\t};\n\n\t// deal_rest_of_hand() {\n\t// \t// once everything else is setup deal out the rest of the community cards\n\t// \twhile (this.game.community_cards.length < 5) {\n\t// \t\tthis.game.community_cards.push(this.deal_card());\n\t// \t}\n\t// };\n\n\tget_winner() {\n\t\t// rank all the players and find who has the best hand\n\t\t// eval winner\n\t\tconst results = find_hand_winner(this.game);\n\t\t// console.log(\"sim hand get winner results\", results);\n\t\t// console.log(\"winner = \" + results.winner.name)\n\t\tfor (let _player of results.winners) {\n\t\t\tif (_player.id == this.player.id) {\n\t\t\t\tthis.wins++;\n\t\t\t}\n\t\t}\n\t\tthis.run_count++;\n\t};\n};", "import { Sim_Hand } from './Sim_Hand';\nimport { Player } from \"./types\";\nimport { add_log_msg } from \"./Log\";\nimport { Game, game } from './Game';\nimport { call_bet, end_turn, place_bet, fold } from '.';\n\nexport function do_ai_turn(player: Player) {\n\tadd_log_msg(\"Starting ai_turn for \" + player.name);\n\tsetTimeout(() => {\n\t\tlet sim_hand: Sim_Hand = new Sim_Hand(game, player);\n\t\t// console.log(sim_hand.results);\n\t\tconst win_percent: number = (sim_hand.results.wins / sim_hand.results.run_count * 100);\n\t\tconsole.log(\"win %: \" + win_percent);\n\t\tadd_log_msg(`AI analysis: Win %: ${win_percent}`);\n\n\t\tconst amount_owed = game.current_hand.current_bet - player.amount_bet_this_round;\n\t\tconsole.log('amount_owed: ' + amount_owed)\n\n\t\tlet percent_willing_to_bet = 0; // how much of their $ are they willing to bet\n\n\t\t// if (win_percent < 5) {\n\t\t// \tpercent_willing_to_bet = .01;\n\t\t// } else if (win_percent < 10) {\n\t\t// \tpercent_willing_to_bet = .03;\n\t\t// } else if (win_percent < 20) {\n\t\t// \tpercent_willing_to_bet = .5;\n\t\t// } else if (win_percent < 40) {\n\t\t// \tpercent_willing_to_bet = .10;\n\t\t// }  else if (win_percent < 60) {\n\t\t// \tpercent_willing_to_bet = .3;\n\t\t// } else {\n\t\t// \tpercent_willing_to_bet = 1;\n\t\t// }\n\n\t\tif (win_percent > 80) {\n\t\t\tpercent_willing_to_bet = 1;\n\t\t} else if (win_percent > 60) {\n\t\t\tpercent_willing_to_bet = 0.5\n\t\t} else if (win_percent > 50) {\n\t\t\tpercent_willing_to_bet = 0.4;\n\t\t} else if (win_percent > 40) {\n\t\t\tpercent_willing_to_bet = 0.3\n\t\t} else if (win_percent > 30) {\n\t\t\tpercent_willing_to_bet = 0.2\n\t\t} else if (win_percent > 20) {\n\t\t\tpercent_willing_to_bet = 0.1\n\t\t} else if (win_percent > 10) {\n\t\t\tpercent_willing_to_bet = 0.05\n\t\t} else if (win_percent > 5) {\n\t\t\tpercent_willing_to_bet = 0.02\n\t\t}\n\t\t\n\t\tconsole.log(\"percent willing to bet: \" + percent_willing_to_bet);\n\t\t\n\n\t\t// let should_raise_or_bet: boolean = false;\n\n\t\t// figure out if the ai should either place a new bet or raise the current bet\n\t\t// do this based on the ai hand strength and how much money they have?\n\n\t\t// if win percent is heigh enough then place/raise bet\n\t\t// how much to bet? determine risk\n\n\t\t\n\t\t// if a bet is below 3% of players money then just call even with bad hand\n\t\t// const cheap_bet_amount = player.money * .03;\n\n\t\t// if (amount_owed < cheap_bet_amount) {\n\t\t// \tcall_bet(player);\n\t\t// \tend_turn(player, false);\n\t\t// }\n\t\t\n\n\t\tconst willing_to_bet = (player.money * percent_willing_to_bet) - player.amount_bet_this_round;\n\t\tconsole.log('willing_to_bet: ' + willing_to_bet)\n\n\t\tlet wants_to_place_bet = false;\n\t\tif (Math.floor(Math.random() * 100) > 50) {\n\t\t\twants_to_place_bet = true;\n\t\t}\n\n\t\tif (willing_to_bet - amount_owed < 50) {\n\t\t\twants_to_place_bet = false;\n\t\t}\n\n\t\tif (amount_owed <= willing_to_bet) {\n\t\t\tif (!wants_to_place_bet) {\n\t\t\t\tif (amount_owed > 0) {\n\t\t\t\t\tcall_bet(player);\n\t\t\t\t\tend_turn(player, false);\n\t\t\t\t} else {\n\t\t\t\t\t// check\n\t\t\t\t\tend_turn(player, false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst amount_to_bet = Math.floor(Math.random() * willing_to_bet) + game.blinds.big;\n\t\t\t\tif (amount_to_bet <= amount_owed) {\n\t\t\t\t\t// if the ai is trying to bet but the amount is less than what they owe, just call instead\n\t\t\t\t\tcall_bet(player);\n\t\t\t\t\tend_turn(player, false);\n\t\t\t\t} else {\n\t\t\t\t\tplace_bet(player, amount_to_bet);\n\t\t\t\t\tend_turn(player, false);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (amount_owed > 0 && amount_owed > willing_to_bet) {\n\t\t\tadd_log_msg(\"AI is folding\");\n\t\t\tfold(player);\n\t\t} else {\n\t\t\tconsole.assert(false);\n\t\t\t\n\t\t\t// if (sim_hand.results.wins > 15) {\n\t\t\t// \tcall_bet(player);\n\t\t\t// \tend_turn(player, false);\n\t\t\t// } else {\n\t\t\t// \tadd_log_msg(\"AI is folding\");\n\t\t\t// \tfold(player);\n\t\t\t// }\n\t\t}\n\n\t\t\n\t}, 500);\n};", "import { Ranked_Hand, Card, Hand_Rank, Card_Type, Cards_By_Suit, Suit } from \"./types\";\nimport { sort_cards, find_pairs, get_cards_with_value, removeDuplicateValues, get_flush_cards, get_four_of_kind_cards } from \".\";\n\n// returns true if the new hand is better than the highest ranked hand;\nexport enum Compare_Result {\n\tWIN,\n\tLOSE,\n\tTIE\n};\n\n// WIN = hand_one won\n// LOSE = hand_two won\n\n\nfunction get_highest_non_matching_cards(hand: Card[], values: Card_Type[]): Card[] {\n\tconst cards: Card[] = [];\n\tfor (let card of hand) {\n\t\tlet match: boolean = false;\n\t\tfor (let value of values) {\n\t\t\tif (card.value == value) match = true;\n\t\t}\n\t\tif (!match) cards.push(card);\n\t}\n\t\n\treturn cards;\n}\n\nfunction get_singles(cards: Card[]): Card[] {\n\tconst singles: Card[] = [];\n\n\tfor (const card of cards) {\n\t\tlet matches = 0;\n\t\tfor (const other_card of cards) {\n\t\t\tif (card.value == other_card.value && card.id != other_card.id) {\n\t\t\t\tmatches++;\n\t\t\t}\n\t\t}\n\t\tif (matches == 0) {\n\t\t\tsingles.push(card);\n\t\t}\n\t}\n\t\n\tsort_cards(singles);\n\n\treturn singles;\n}\n\nexport function get_trips(hand: Card[]): number[] {\n\tconst trips: number[] = [];\n\thand.forEach((card: Card) => {\n\t\tconst count = hand.filter((other_card: Card) => other_card.value === card.value).length;\n\t\tif (count == 3) {\n\t\t\tconst already_found = trips.filter(value => value === card.value).length == 0 ? false : true;\n\t\t\tif (!already_found) trips.push(card.value);\n\t\t}\n\t})\n\treturn trips;\n}\n\nexport function get_pairs_exact(hand: Card[]): number[] {\n\tconst pairs: number[] = [];\n\thand.forEach((card: Card) => {\n\t\tconst count = hand.filter(other_card => other_card.value === card.value).length;\n\t\tif (count == 2) {\n\t\t\tconst already_found = pairs.filter(value => value === card.value).length == 0 ? false : true;\n\t\t\tif (!already_found) pairs.push(card.value);\n\t\t}\n\t})\n\treturn pairs;\n}\n\nfunction get_three_of_kind_cards(hand: Card[]): Card[] | false {\n\tfor (let card of hand) {\n\t\tconst temp_cards: Card[] = [];\n\n\t\tfor (let other_card of hand) {\n\t\t\tif (card.value == other_card.value) temp_cards.push(other_card);\n\t\t}\n\n\t\tif (temp_cards.length == 3) {\n\t\t\treturn temp_cards;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function get_straight_cards(hand: Card[]): Card[] | false {\n\thand = sort_cards(hand);\n\thand = removeDuplicateValues(hand);\n\n\tif (hand.length < 5) return false;\n\n\tlet temp_cards: Card[] = [];\n\n\tfor (let card of hand) {\n\t\tif (temp_cards.length == 0) temp_cards.push(card);\n\n\t\tif (card.value == temp_cards[temp_cards.length - 1].value - 1) {\n\t\t\ttemp_cards.push(card);\n\t\t\tif (temp_cards.length == 5) return temp_cards;\n\t\t}\n\t\telse {\n\t\t\ttemp_cards = [];\n\t\t\ttemp_cards.push(card);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction get_cards_by_suit(hand: Card[]): Cards_By_Suit {\n\tconst cards: Cards_By_Suit = {\n\t\thearts: [],\n\t\tspades: [],\n\t\tclubs: [],\n\t\tdiamonds: []\n\t}\n\n\tfor (let card of hand) {\n\t\tif (card.suit == Suit.HEARTS) cards.hearts.push(card);\n\t\tif (card.suit == Suit.SPADES) cards.spades.push(card);\n\t\tif (card.suit == Suit.CLUBS) cards.clubs.push(card);\n\t\tif (card.suit == Suit.DIAMONDS) cards.diamonds.push(card);\n\t}\n\n\treturn cards;\n}\n\nfunction get_straight_flush_cards(hand: Card[]): Card[] | false {\n\tconst cards: Cards_By_Suit = get_cards_by_suit(hand);\n\n\tfor (const [key, value] of Object.entries(cards)) {\n\t\tif (value.length >= 5) return get_straight_cards(sort_cards(value));\n\t}\n\n\treturn false;\n}\n\n\n// find the best five cards for each hand rank\n// each hand can start w/ five to seven cards\n// sort the cards by if their being used\nexport function find_five_best_cards(ranked_hand: Ranked_Hand): Card[] {\n\tconsole.assert(ranked_hand.hand.length >= 5, \"Hand size is less than 5\");\n\t// console.log(\"starting find_five_used_cards\");\n\t// console.log(\"hand: \", player.hand);\n\t// console.log(\"final_cards: \", player.final_hand_cards);\n\t\n\t// let final_cards = player.final_hand_cards;\n\n\t/* if we are testing the final cards array is empty, fix??\n\t\tso just set it to their hand\n\t */\n\t// if (final_cards.length == 0) {\n\t// \tfinal_cards = player.hand;\n\t// }\n\n\t// console.assert(final_cards.length > 0, \"Final Cards arr is empty\");\n\n\t// player.best_cards = [];\n\tconst hand = ranked_hand.hand;\n\tlet best_cards: Card[] = [];\n\n\tswitch(ranked_hand.rank) {\n\t\tcase Hand_Rank.HIGH_CARD: {\n\t\t\tbest_cards = hand.slice(0, 5);\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.PAIR: {\n\t\t\tconst pairs = find_pairs(hand);\n\t\t\tconst cards_with_value = get_cards_with_value(hand, pairs[0]);\n\t\t\tbest_cards.push(...cards_with_value);\n\n\t\t\t// get remaining 3 best cards in hand\n\t\t\tconst hightest_non_matching = get_highest_non_matching_cards(hand, [pairs[0]]);\n\t\t\tbest_cards.push(...hightest_non_matching.slice(0, 3));\n\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.TWO_PAIR: {\n\t\t\tconst pairs = find_pairs(hand);\n\t\t\tconst first_pair_cards: Card[] = get_cards_with_value(hand, pairs[0]);\n\t\t\tbest_cards.push(...first_pair_cards);\n\t\t\tconst second_pair_cards: Card[] = get_cards_with_value(hand, pairs[1]);\n\t\t\tbest_cards.push(...second_pair_cards);\n\n\t\t\t// add last card\n\t\t\tconst hightest_non_matching = get_highest_non_matching_cards(hand, [pairs[0], pairs[1]]);\n\t\t\tbest_cards.push(...hightest_non_matching.slice(0, 1));\n\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.THREE_OF_KIND: {\n\t\t\tconst three_of_kind_cards: Card[] | false = get_three_of_kind_cards(hand);\n\t\t\tif (three_of_kind_cards) {\n\t\t\t\tbest_cards.push(...three_of_kind_cards);\n\t\t\t\tconst hightest_non_matching = get_highest_non_matching_cards(hand, [three_of_kind_cards[0].value]);\n\t\t\t\tbest_cards.push(...hightest_non_matching.slice(0, 2));\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.STRAIGHT: {\n\t\t\tconst straight_cards: Card[] | false = get_straight_cards(hand);\n\t\t\tif (straight_cards) best_cards.push(...straight_cards);\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.FLUSH: {\n\t\t\tconst flush_cards: Card[] | false = get_flush_cards(hand);\n\t\t\tif (flush_cards) best_cards.push(...flush_cards);\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.FULL_HOUSE: {\n\t\t\tconst trips = get_trips(hand);\n\t\t\tconst pair = get_pairs_exact(hand);\n\t\t\t\n\t\t\tfor (let card of hand) {\n\t\t\t\tif (card.value == trips[0]) best_cards.push(card);\n\t\t\t}\n\n\t\t\t// sometimes in a full house hand there are two trips instead of a trip and a pair\n\t\t\tif (trips.length == 2) {\n\t\t\t\tfor (let card of hand) {\n\t\t\t\t\tif (card.value == trips[1] && best_cards.length < 5) best_cards.push(card);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let card of hand) {\n\t\t\t\t\tif (card.value == pair[0]) best_cards.push(card);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\n\t\t\t// const full_house_cards: Card[] | false = get_full_house_cards(hand);\n\t\t\t// if (full_house_cards) best_cards.push(...full_house_cards);\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.FOUR_OF_KIND: {\n\t\t\tconst four_of_kind_cards: Card[] | false = get_four_of_kind_cards(hand);\n\t\t\tif (four_of_kind_cards) best_cards.push(...four_of_kind_cards);\n\t\t\tconst hightest_non_matching = get_highest_non_matching_cards(hand, [four_of_kind_cards[0].value]);\n\t\t\tbest_cards.push(...hightest_non_matching.slice(0, 1));\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.STRAIGHT_FLUSH: {\n\t\t\tconst straight_flush_cards: Card[] | false = get_straight_flush_cards(hand);\n\t\t\tif (straight_flush_cards) best_cards.push(...straight_flush_cards);\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Rank.ROYAL_FLUSH: {\n\t\t\tconst royal_flush_cards: Card[] | false = get_royal_flush_cards(hand);\n\t\t\tif (royal_flush_cards) best_cards.push(...royal_flush_cards);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// console.log(\"best_cards: \", best_cards)\n\tranked_hand.player.best_cards = best_cards;\n\n\treturn best_cards;\n}\n\nfunction get_royal_flush_cards(hand: Card[]): Card[] | false {\n\tconst straight_cards = get_straight_cards(hand);\n\tif (straight_cards && straight_cards[0].value == Card_Type.ACE) {\n\t\treturn straight_cards;\n\t}\n\treturn false;\n}\n\nexport function compare_hands(ranked_hand_one: Ranked_Hand, ranked_hand_two: Ranked_Hand): Compare_Result {\n\tfind_five_best_cards(ranked_hand_one);\n\tfind_five_best_cards(ranked_hand_two);\n\n\tconst hand_one_cards = ranked_hand_one.hand;\n\tconst hand_two_cards = ranked_hand_two.hand;\n\n\tif (ranked_hand_one.rank > ranked_hand_two.rank) return Compare_Result.WIN;\n\tif (ranked_hand_one.rank < ranked_hand_two.rank) return Compare_Result.LOSE;\n\n\tconst hand_one_pairs: number[] = get_pairs_exact(ranked_hand_one.hand); \n\tconst hand_two_pairs: number[] = get_pairs_exact(ranked_hand_two.hand);\n\n\tconst hand_one_trips: number[] = get_trips(hand_one_cards);\n\tconst hand_two_trips: number[] = get_trips(hand_two_cards);\n\n\n\tswitch (ranked_hand_one.rank) {\n\t\tcase Hand_Rank.HIGH_CARD: {\n\n\t\t\tfor (let i = 0; i < 1; i++) {\n\t\t\t\tif (hand_one_cards[i].value > hand_two_cards[i].value) return Compare_Result.WIN; \n\t\t\t\tif (hand_one_cards[i].value < hand_two_cards[i].value) return Compare_Result.LOSE;\n\t\t\t}\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.PAIR: {\n\t\t\tif (hand_one_pairs[0] > hand_two_pairs[0]) return Compare_Result.WIN;\n\t\t\tif (hand_one_pairs[0] < hand_two_pairs[0]) return Compare_Result.LOSE;\n\n\t\t\tif (hand_one_cards[4].value > hand_two_cards[4].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[4].value < hand_two_cards[4].value) return Compare_Result.LOSE;\n\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.TWO_PAIR: {\n\t\t\t// console.log(hand_one_cards, hand_two_cards)\n\t\t\t// console.log(hand_one_pairs, hand_two_pairs)\n\t\t\tif (hand_one_pairs[0] > hand_two_pairs[0]) return Compare_Result.WIN;\n\t\t\tif (hand_one_pairs[0] < hand_two_pairs[0]) return Compare_Result.LOSE;\n\t\t\tif (hand_one_pairs[1] > hand_two_pairs[1]) return Compare_Result.WIN;\n\t\t\tif (hand_one_pairs[1] < hand_two_pairs[1]) return Compare_Result.LOSE;\n\n\t\t\t// console.log(\"debug two pair v two pair\", hand_one_cards, hand_two_cards)\n\n\t\t\tconst hand_one_singles = get_singles(hand_one_cards);\n\t\t\tconst hand_two_singles = get_singles(hand_two_cards);\n\n\t\t\t// console.log(\"hand one singles: \", hand_one_singles);\n\t\t\t// console.log(\"hand two singles: \", hand_two_singles);\n\n\t\t\tif (hand_one_singles[0].value > hand_two_singles[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_singles[0].value < hand_two_singles[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.WIN;\n\t\t\t\n\t\t\t// // this doesn't work??\n\t\t\t// if (hand_one_cards[4].value > hand_two_cards[4].value) return Compare_Result.WIN;\n\t\t\t// if (hand_one_cards[4].value < hand_two_cards[4].value) return Compare_Result.LOSE;\n\n\t\t\t// return Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.THREE_OF_KIND: {\n\t\t\t// console.log(hand_one_cards, hand_two_cards)\n\t\t\t// console.log(hand_one_pairs, hand_two_pairs)\n\t\t\tif (hand_one_trips[0] > hand_two_trips[0]) return Compare_Result.WIN;\n\t\t\tif (hand_one_trips[0] < hand_two_trips[0]) return Compare_Result.LOSE;\n\n\t\t\tconst hand_one_singles = get_singles(hand_one_cards);\n\t\t\tconst hand_two_singles = get_singles(hand_two_cards);\n\n\t\t\tif (hand_one_singles[0].value > hand_two_singles[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_singles[0].value < hand_two_singles[0].value) return Compare_Result.LOSE;\n\t\t\tif (hand_one_singles[1].value > hand_two_singles[1].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_singles[1].value < hand_two_singles[1].value) return Compare_Result.LOSE;\n\n\t\t\treturn Compare_Result.TIE;\n\n\t\t\t// // this doesn't work??\n\t\t\t// if (hand_one_cards[3].value > hand_two_cards[3].value) return Compare_Result.WIN;\n\t\t\t// if (hand_one_cards[3].value < hand_two_cards[3].value) return Compare_Result.LOSE;\n\n\t\t\t// return Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.STRAIGHT: {\n\t\t\tif (hand_one_cards[0].value > hand_two_cards[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[0].value < hand_two_cards[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.FLUSH: {\n\t\t\tif (hand_one_cards[0].value > hand_two_cards[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[0].value < hand_two_cards[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.FULL_HOUSE: {\n\t\t\tif (hand_one_trips[0] > hand_two_trips[0]) return Compare_Result.WIN;\n\t\t\tif (hand_one_trips[0] < hand_two_trips[0]) return Compare_Result.LOSE;\n\t\t\telse {\n\t\t\t\tif (hand_one_pairs[0] > hand_two_pairs[0]) return Compare_Result.WIN;\n\t\t\t\tif (hand_one_pairs[0] < hand_two_pairs[0]) return Compare_Result.LOSE;\n\t\t\t}\n\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.FOUR_OF_KIND: {\n\t\t\tif (hand_one_cards[0].value > hand_two_cards[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[0].value < hand_two_cards[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\tif (hand_one_cards[4].value > hand_two_cards[4].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[4].value < hand_two_cards[4].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.STRAIGHT_FLUSH: {\n\t\t\tif (hand_one_cards[0].value > hand_two_cards[0].value) return Compare_Result.WIN;\n\t\t\tif (hand_one_cards[0].value < hand_two_cards[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t\tcase Hand_Rank.ROYAL_FLUSH: {\n\t\t\tif (hand_one_cards[0].value > hand_two_cards[0].value) return Compare_Result.WIN;\n\t\t\telse if (hand_one_cards[0].value < hand_two_cards[0].value) return Compare_Result.LOSE;\n\t\t\t\n\t\t\treturn Compare_Result.TIE;\n\t\t}\n\t}\n\n\treturn Compare_Result.TIE;\n\t\n\t// \tcase Hand_Rank.THREE_OF_KIND: {\n\t// \t\tif (highest_ranked_pairs[0] > current_hand_pairs[0]) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_pairs[0] < current_hand_pairs[0]) result = Compare_Result.WIN;\n\t// \t\telse {\n\t// \t\t\tif (highest_ranked_best_cards[3].value > current_hand_best_cards[3].value) result = Compare_Result.LOSE;\n\t// \t\t\telse if (highest_ranked_best_cards[3].value < current_hand_best_cards[3].value) result = Compare_Result.WIN;\n\t// \t\t\telse {\n\t// \t\t\t\tif (highest_ranked_best_cards[4].value > current_hand_best_cards[4].value) result = Compare_Result.LOSE;\n\t// \t\t\t\telse if (highest_ranked_best_cards[4].value < current_hand_best_cards[4].value) result = Compare_Result.WIN;\n\t// \t\t\t\telse result = Compare_Result.TIE;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.STRAIGHT: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n\t// \t\telse Compare_Result.TIE;\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.FLUSH: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n\t// \t\telse Compare_Result.TIE;\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.FULL_HOUSE: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) {\n\t// \t\t\treturn Compare_Result.LOSE;\n\t// \t\t} else if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) {\n\t// \t\t\treturn Compare_Result.WIN;\n\t// \t\t} else {\n\t// \t\t\tif (highest_ranked_best_cards[3].value > current_hand_best_cards[0].value) {\n\t// \t\t\t\treturn Compare_Result.LOSE;\n\t// \t\t\t} else if (highest_ranked_best_cards[3].value < current_hand_best_cards[3].value) {\n\t// \t\t\t\treturn Compare_Result.WIN;\n\t// \t\t\t} \n\t// \t\t}\n\t// \t\t// if (highest_ranked_pairs[0] > current_hand_pairs[0]) result = Compare_Result.LOSE;\n\t// \t\t// else if (highest_ranked_pairs[0] < current_hand_pairs[0]) result = Compare_Result.WIN;\n\t// \t\t// else {\n\t// \t\t// \tif (highest_ranked_pairs[1] > current_hand_pairs[1]) result = Compare_Result.LOSE;\n\t// \t\t// \telse if (current_hand_pairs[1] < current_hand_pairs[1]) result = Compare_Result.WIN;\n\t// \t\t// \telse result = Compare_Result.TIE;\n\t// \t\t// }\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.FOUR_OF_KIND: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n\t// \t\telse {\n\t// \t\t\tif (highest_ranked_best_cards[4].value > current_hand_best_cards[4].value) result = Compare_Result.LOSE;\n\t// \t\t\telse if (highest_ranked_best_cards[4].value < current_hand_best_cards[4].value) result = Compare_Result.WIN;\n\t// \t\t\telse result = Compare_Result.TIE;\n\t// \t\t}\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.STRAIGHT_FLUSH: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n\t// \t\telse Compare_Result.TIE;\n\t// \t\tbreak;\n\t// \t}\n\t// \tcase Hand_Rank.ROYAL_FLUSH: {\n\t// \t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n\t// \t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n\t// \t\telse Compare_Result.TIE;\n\t// \t\tbreak;\n\t// \t}\n\t// }\n\t// }\n}", "import { Suit, Card, Player, Player_Type, Ranked_Hand, Hand_Rank, Card_Type, Hand_Phase, Hand_Results, Card_Info, Cards_By_Suit } from \"./types\"\nimport { Sim_Hand } from \"./Sim_Hand\";\nimport { log, add_log_msg } from './Log';\nimport { el, child_el} from './UI';\nimport { create_deck, deal_new_hand } from \"./Deck\";\nimport { create_player, create_players, Game, game } from \"./Game\";\nimport { do_ai_turn } from \"./ai\";\nimport { Compare_Result, compare_hands, get_straight_cards } from \"./compare_hands\";\n\nfunction init() {\n\t// game.dev_do_next_turn = true; // manually do each ai turn\n\n\tif (game.dev_do_next_turn) {\n\t\tconst next_el = document.createElement(\"div\");\n\t\tnext_el.innerHTML = \"DO NEXT TURN\";\n\t\tnext_el.className = \"do_next_turn\";\n\t\tnext_el.addEventListener(\"click\", () => {\n\t\t\tconsole.log(\"doing next turn\")\n\t\t\tif (game.active_player.id == 0) return;\n\t\t\tstart_turn(game.active_player, true);\n\t\t});\n\n\t\tconst game_el = document.querySelector(\".game\");\n\t\tgame_el.appendChild(next_el);\n\t}\n\n\taddEventListeners();\n\n\tgame.deck = create_deck();\n\tgame.players = create_players();\n\tgame.human_player = game.players[0];\n\n\tdeal_new_hand();\n};\n\nfunction addEventListeners() {\n\tel(\".deal_new_hand_button\").addEventListener(\"click\", deal_new_hand);\n\n\tel(\".check\").addEventListener(\"click\", () => {\n\t\tend_turn(game.human_player, false);\n\t});\n\n\tel(\".fold\").addEventListener(\"click\", () => {\n\t\tfold(game.human_player);\n\t\t// end_turn(game.human_player, false);\n\t});\n\n\tconst bet_range_el: HTMLInputElement = el(\".bet_range\") as HTMLInputElement;\n\t\n\tbet_range_el.addEventListener(\"input\", e => {\n\t\tel(\".bet_amount\").innerHTML = bet_range_el.value;\n\t\tif (parseInt(bet_range_el.value) == game.current_hand.current_bet) {\n\t\t\tel(\".call\").classList.remove(\"hide\");\n\t\t} else {\n\t\t\tel(\".call\").classList.add(\"hide\");\n\t\t}\n\t});\n\n\tel(\".bet\").addEventListener(\"click\", () => {\n\t\thumanBet();\n\t});\n\n\tel(\".call\").addEventListener(\"click\", () => {\n\t\tcall_bet(game.human_player);\n\t\tend_turn(game.human_player, false);\n\t});\n};\n\n\n\nexport function deal_card(deck: Card[]): Card {\n\tlet cardPosInDeck = Math.floor(Math.random() * game.deck.length);\n\tlet card = game.deck[cardPosInDeck];\n\tdeck.splice(cardPosInDeck, 1);\n\treturn card;\n}\n\nexport function dev_deal_cards(deck: Card[], cards_to_deal: Card_Info[]): Card[] {\n\tconst cards: Card[] = [];\n\tfor (let card_info of cards_to_deal) {\n\t\tfor (let card of deck) {\n\t\t\tif (card.suit == card_info.suit && card.value == card_info.type) {\n\t\t\t\tcards.push(card);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cards;\n}\n\nexport function deal_cards(player: Player, numCardsToDeal: number) {\n\tlet cardsDelt = 0;\n\twhile (cardsDelt < numCardsToDeal) {\n\t\tcardsDelt++;\n\t\tplayer.hand.push(deal_card(game.deck));\n\t}\n};\n\nexport function update_player_ui() {\n\tdocument.querySelectorAll(\".card\").forEach(e => e.innerHTML = \"\");\n\tfor (let player of game.players) {\n\t\tlet player_el = el(`.${player.name}`);\n\t\tlet cards_el = child_el(player_el, \".cards\");\n\t\tlet money_el = child_el(player_el, \".player_money\");\n\t\tlet amount_bet_el = child_el(player_el, \".amount_bet\");\n\t\t\n\t\tmoney_el.innerHTML = player.money.toString();\n\t\tamount_bet_el.innerHTML = player.amount_bet_this_round.toString();\n\n\t\tfor (let card of Array.from(cards_el.children)) {\n\t\t\tif (game.hand_winners.length > 0 || player.id == 0) {\n\t\t\t\tif (player.has_folded) card.innerHTML = \"\";\n\t\t\t\telse if (card.classList.contains(\"card1\")) card.innerHTML = getCardImage(player.hand[0].value, player.hand[0].suit, false);\n\t\t\t\telse if (card.classList.contains(\"card2\")) card.innerHTML = getCardImage(player.hand[1].value, player.hand[1].suit, false);\t\t\n\t\t\t} else {\n\t\t\t\tif (player.has_folded) card.innerHTML = \"\";\n\t\t\t\telse if (card.classList.contains(\"card1\")) card.innerHTML = card_back();\n\t\t\t\telse if (card.classList.contains(\"card2\")) card.innerHTML = card_back();\n\t\t\t}\n\t\t}\n\t}\n};\n\nfunction card_back() {\n\treturn \"<img class='card_image' src='./assets/deck/card_back.svg'>\";\n};\n\nexport function getCardImage(card_value: number | string, suit: Suit, is_final_cards: boolean) {\n\tlet value = card_value > 10 ? Card_Type[card_value] : card_value; \n\tlet imageName = value + \"_of_\" + Suit[suit] + \".svg\";\n\timageName = imageName.toLowerCase();\n\n\tif (is_final_cards) {\n\t\tlet image = \"<img class='final_card_image' src='./assets/deck/\" + imageName + \"'>\";\n\t\treturn image;\n\t} else {\n\t\tlet image = \"<img class='card_image' src='./assets/deck/\" + imageName + \"'>\";\n\t\treturn image;\n\t}\n};\n\nfunction updateCommunityCards() {\n\tswitch (game.hand_phase) {\n\t\tcase Hand_Phase.PREFLOP:\n\t\t\tbreak;\n\t\tcase Hand_Phase.FLOP:\n\t\t\tdealCommunityCards(3);\n\t\t\tbreak;\n\t\tcase Hand_Phase.TURN:\n\t\t\tdealCommunityCards(1);\n\t\t\tbreak;\n\t\tcase Hand_Phase.RIVER:\n\t\t\tdealCommunityCards(1);\n\t\t\tbreak;\n\t}\n\n\tupdateCommunityCardElems();\n};\n\nfunction dealCommunityCards(numToDeal: number) {\n\tlet cardsDelt = 0;\n\twhile (cardsDelt < numToDeal) {\n\t\tcardsDelt++;\n\t\tlet cardPosInDeck = Math.floor(Math.random() * game.deck.length);\n\t\tlet card = game.deck[cardPosInDeck];\n\t\tgame.community_cards.push(card);\n\t\tgame.deck.splice(cardPosInDeck, 1);\n\t}\n};\n\nexport function start_betting_round() {\n\tadd_log_msg(\"Starting new betting round\");\n\t\n\tgame.round_current_player_index = 0;\n\tgame.active_player = game.round_order[game.round_current_player_index];\n\t\n\tif (game.hand_phase != Hand_Phase.PREFLOP) {\n\t\t// reset current hand if not first round (blinds)\n\t\tconsole.log(\"reseting current bet and player bets\")\n\t\tgame.current_hand.current_bet = 0;\n\t\tgame.current_hand.temp_player_bet = 0;\n\t\tgame.players.forEach(player => {\n\t\t\tplayer.amount_bet_this_round = 0;\n\t\t});\n\t}\n\n\tupdateCommunityCards(); // check if we need to deal out any community cards to start the round\n\n\t// update the human player's current hand rank\n\tlet current_rank_el = document.querySelector(\".player0\").querySelector(\".current_rank\");\n\tcurrent_rank_el.innerHTML = Hand_Rank[rankHand(game.human_player, game.community_cards).rank];\n\t\n\tstart_turn(game.active_player);\n};\n\nexport function updateCommunityCardElems() {\n\t// after dealing update the DOM elems to show the community cards\n\tconst community_cards_el = el(\".community_cards\");\n\tcommunity_cards_el.innerHTML = \"\";\n\n\tfor (let card of game.community_cards) {\n\t\tcommunity_cards_el.innerHTML += `<div class=\"community_card\">${getCardImage(card.value, card.suit, false)}</div>`\n\t}\n};\n\nexport function call_bet(player: Player): void {\n\tconst amount = game.current_hand.current_bet - player.amount_bet_this_round;\n\tadd_log_msg(`${player.name} calls with $${amount}`);\n\tadd_money_to_pot(player, amount);\n}\n\nexport function place_bet(player: Player, amount: number) {\n\tadd_log_msg(`${player.name} places best of $${amount}`);\n\t// take into acount the amount already owed by the player\n\t// add the total amount of bet to the pot, but only increase by difference between amount bet and amount the player already owes\n\tadd_money_to_pot(player, amount - player.amount_bet_this_round);\n\tconst amount_to_increase = amount - game.current_hand.current_bet; \n\tgame.current_hand.current_bet += amount_to_increase;\n\tsetNewRoundOrderAfterBet(player);\n}\n\n\n\nfunction humanTurn(player: Player) {\n\tadd_log_msg(\"Starting human player turn\");\n\t\n\tif (player.has_folded) {\n\t\thide_bet_options();\n\t\tend_turn(player, false);\n\t} else {\n\t\tshow_bet_options();\n\t\trender_bet_options();\n\t}\n};\n\nfunction show_bet_options() {\n\tel(\".bet_options\").classList.remove(\"bet_options_hide\");\n}\n\nfunction hide_bet_options() {\n\tel(\".bet_options\").classList.add(\"bet_options_hide\");\n}\n\nfunction render_bet_options() {\n\t// set the player bet/call element to show bet or call depending on if the roundBet is > 0\n\t// also set the min bet ammount if it is call\n\n\t// console.log(\"render_bet_options\")\n\n\tconst bet_options_el = el(\".bet_options\");\n\tif (game.current_hand.current_bet > 0) {\n\t\tel(\".check\").classList.add(\"bet_button_hide\");\n\t\tel(\".call\").classList.remove(\"bet_button_hide\");\n\n\t\t// el(\".bet_amount\").innerHTML = game.current_hand.current_bet.toString();\n\t\t\n\t} else {\n\t\tel(\".check\").classList.remove(\"bet_button_hide\");\n\t\tel(\".call\").classList.add(\"bet_button_hide\");\n\t\t\n\t}\n\n\tconst bet_amount = game.current_hand.current_bet - game.human_player.amount_bet_this_round;\n\tel(\".bet_amount\").innerHTML = bet_amount.toString();\n\n\tconst bet_range_el = el(\".bet_range\") as HTMLInputElement;\n\tbet_range_el.min = game.current_hand.current_bet.toString();\n\tbet_range_el.max = game.human_player.money.toString();\n\tbet_range_el.value = game.current_hand.current_bet.toString();\n\n\tconst call_btn_el = el(\".call\");\n\t// console.log(game.current_hand.current_bet, bet_range_el.value)\n\tif (game.current_hand.current_bet == parseInt(bet_range_el.value)) {\n\t\tcall_btn_el.classList.remove(\"hide\");\n\t} else {\n\t\tcall_btn_el.classList.add(\"hide\");\n\t}\n\n};\n\nexport function end_turn(player: Player, newBetHasBeenPlaced: boolean) {\n\t\n\tif (player.has_folded) {\n\t\tadd_log_msg(`Ending turn b/c player ${player.name} has folded`);\n\t} else {\n\t\tadd_log_msg(\"Ending turn for player \" + player.name);\n\t}\n\n\tif (player.type == Player_Type.HUMAN) {\n\t\thide_bet_options();\n\t}\n\n\t// if a new bet has been placed then reset the round order\n\tif (newBetHasBeenPlaced) {\n\t\tsetNewRoundOrderAfterBet(player);\n\t\tconst next_player = findNextPlayer();\n\t\tstart_turn(next_player);\n\t} else { // if no new bet then continue the round as normal\n\t\tif (check_if_round_complete(player)) {\n\t\t\tendOfRound();\n\t\t} else {\n\t\t\t// if not the end of round then move on to the next player\n\t\t\tconst next_player = findNextPlayer();\n\t\t\tstart_turn(next_player);\n\t\t}\n\t}\n\n\tconst player_el: Element = el(`.${player.name}`);\n\tplayer_el.classList.remove(\"active_player\");\n\n\tupdate_player_ui();\n};\n\nfunction check_if_round_complete(player: Player): boolean {\n\tif (player.id == game.round_order[game.round_order.length - 1].id) {\n\t\t//log('last player in roundOrder has ended their turn')\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nfunction findNextPlayer(): Player {\n\tgame.round_current_player_index++;\n\tconst next_player: Player = game.round_order[game.round_current_player_index];\n\treturn next_player;\n};\n\nfunction start_turn(player: Player, doing_next_turn: boolean = false) {\n\tgame.active_player = player;\n\tif (game.dev_do_next_turn && !doing_next_turn && player.id != 0) return; // skip this if we are doing it manually\n\n\tconsole.log(\"starting turn for \" + player.name);\n\tif (player.has_folded) {\n\t\tend_turn(player, false);\n\t} else {\n\t\tadd_log_msg(\"Starting turn for player \" + player.name);\n\t\tadd_log_msg(`Current bet is $${game.current_hand.current_bet}`);\n\t\tadd_log_msg(`${player.name} has put up $${player.amount_bet_this_round}`);\n\t\tadd_log_msg(`${player.name} needs to call $${game.current_hand.current_bet - player.amount_bet_this_round}`);\n\t\tconst player_el: Element = el(`.${player.name}`);\n\t\tplayer_el.classList.add(\"active_player\");\n\n\t\tgame.active_player = player;\n\n\t\tif (player.type == Player_Type.AI) {\n\t\t\tdo_ai_turn(player);\n\t\t} else {\n\t\t\thumanTurn(player);\n\t\t}\t\t\n\t}\n};\n\nfunction endOfRound() {\n\tadd_log_msg(\"End of round\");\n\t// the current betting round has ended, move on to the next betting round / determine winner\n\t// console.log(\"end of round: \" + game.hand_phase);\n\t// showPrivateCards = false; // make sure not to show the ai players cards, unless it is end of hand\n\t\n\tswitch (game.hand_phase) {\n\t\tcase Hand_Phase.PREFLOP: {\n\t\t\tadd_log_msg(\"Ending game phase Preflop\");\n\t\t\tgame.hand_phase = Hand_Phase.FLOP;\n\t\t\tstart_betting_round();\n\t\t\tbreak;\n\t\t}\n\t\tcase Hand_Phase.FLOP:\n\t\t\tadd_log_msg(\"Ending game phase Flop\");\n\t\t\tgame.hand_phase = Hand_Phase.TURN;\n\t\t\tstart_betting_round();\n\t\t\tbreak;\n\t\tcase Hand_Phase.TURN:\n\t\t\tadd_log_msg(\"Ending game phase Turn\");\n\t\t\tgame.hand_phase = Hand_Phase.RIVER;\n\t\t\tstart_betting_round();\n\t\t\tbreak;\n\t\tcase Hand_Phase.RIVER:\n\t\t\tadd_log_msg(\"Ending game phase River\");\n\t\t\tgame.hand_phase = Hand_Phase.SHOWDOWN;\n\t\t\tendOfRound(); // immediately move to end of showdown, rank hands \n\t\t\t//startBettingRound();\n\t\t\tbreak;\n\t\tcase Hand_Phase.SHOWDOWN:\n\t\t\tadd_log_msg(\"Ending game phase Showdown\");\n\n\t\t\t// end of the hand\n\t\t\tend_of_hand();\n\n\t\t\tbreak;\n\t}\n};\n\nfunction end_of_hand() {\n\t// showPrivateCards = true;\n\tadd_log_msg(\"End of hand\");\n\t\n\tfind_hand_winner(game); // find the winner of the current hand\n\tupdate_player_ui(); // update to show ai cards\n\ttoggle_end_of_hand_el(); // show the deal new hand btn, allow the player to start the next round\n\tgame.active_player = null; // to turn off betting options ui elem\n}\n\n\n\n\n\n\n// function compare_hand_to_highest_ranked(highestRankedHand: Ranked_Hand, rankedHand: Ranked_Hand): Compare_Result {\n// \tlet result: Compare_Result = Compare_Result.LOSE;\n\t\n// \tfind_five_best_cards(highestRankedHand)\n// \tfind_five_best_cards(rankedHand);\n\n// \tif (rankedHand.rank > highestRankedHand.rank) {\n// \t\tresult = Compare_Result.WIN;\n// \t\treturn result;\n// \t}\n\n// \tconst highest_ranked_best_cards = highestRankedHand.player.best_cards;\n// \tconst current_hand_best_cards = rankedHand.player.best_cards;\n// \tconst highest_ranked_pairs = findPairs(highestRankedHand.hand);\n// \tconst current_hand_pairs = findPairs(rankedHand.hand);\n\n// \tif (rankedHand.rank == highestRankedHand.rank) { // if we found a tied rank\n// \t\tswitch (rankedHand.rank) {\n// \t\t\tcase Hand_Rank.HIGH_CARD: {\n// \t\t\t\t// let done = false;\n// \t\t\t\tfor (let i = 0; i < highest_ranked_best_cards.length; i++) {\n// \t\t\t\t\t// if (done) continue;\n// \t\t\t\t\tif (highest_ranked_best_cards[i].value > current_hand_best_cards[i].value) {\n// \t\t\t\t\t\tresult = Compare_Result.LOSE;\n// \t\t\t\t\t\treturn result;\n// \t\t\t\t\t\t// done = true;\n// \t\t\t\t\t} else if (highest_ranked_best_cards[i].value < current_hand_best_cards[i].value) {\n// \t\t\t\t\t\tresult = Compare_Result.WIN;\n// \t\t\t\t\t\treturn result;\n// \t\t\t\t\t\t// done = true;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.TWO_PAIR: {\n// \t\t\t\tif (highest_ranked_pairs[0] > current_hand_pairs[0]) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_pairs[0] < current_hand_pairs[0]) result = Compare_Result.WIN;\n// \t\t\t\telse {\n// \t\t\t\t\tif (highest_ranked_pairs[1] > current_hand_pairs[1]) result = Compare_Result.LOSE;\n// \t\t\t\t\telse if (current_hand_pairs[1] < current_hand_pairs[1]) result = Compare_Result.WIN;\n// \t\t\t\t\telse {\n// \t\t\t\t\t\t// handle kicker\n// \t\t\t\t\t\tif (highest_ranked_best_cards[4].value > current_hand_best_cards[4].value) result = Compare_Result.LOSE;\n// \t\t\t\t\t\telse if (highest_ranked_best_cards[4].value < current_hand_best_cards[4].value) result = Compare_Result.WIN;\n// \t\t\t\t\t\telse result = Compare_Result.TIE;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.THREE_OF_KIND: {\n// \t\t\t\tif (highest_ranked_pairs[0] > current_hand_pairs[0]) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_pairs[0] < current_hand_pairs[0]) result = Compare_Result.WIN;\n// \t\t\t\telse {\n// \t\t\t\t\tif (highest_ranked_best_cards[3].value > current_hand_best_cards[3].value) result = Compare_Result.LOSE;\n// \t\t\t\t\telse if (highest_ranked_best_cards[3].value < current_hand_best_cards[3].value) result = Compare_Result.WIN;\n// \t\t\t\t\telse {\n// \t\t\t\t\t\tif (highest_ranked_best_cards[4].value > current_hand_best_cards[4].value) result = Compare_Result.LOSE;\n// \t\t\t\t\t\telse if (highest_ranked_best_cards[4].value < current_hand_best_cards[4].value) result = Compare_Result.WIN;\n// \t\t\t\t\t\telse result = Compare_Result.TIE;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.STRAIGHT: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n// \t\t\t\telse Compare_Result.TIE;\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.FLUSH: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n// \t\t\t\telse Compare_Result.TIE;\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.FULL_HOUSE: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) {\n// \t\t\t\t\treturn Compare_Result.LOSE;\n// \t\t\t\t} else if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) {\n// \t\t\t\t\treturn Compare_Result.WIN;\n// \t\t\t\t} else {\n// \t\t\t\t\tif (highest_ranked_best_cards[3].value > current_hand_best_cards[0].value) {\n// \t\t\t\t\t\treturn Compare_Result.LOSE;\n// \t\t\t\t\t} else if (highest_ranked_best_cards[3].value < current_hand_best_cards[3].value) {\n// \t\t\t\t\t\treturn Compare_Result.WIN;\n// \t\t\t\t\t} \n// \t\t\t\t}\n// \t\t\t\t// if (highest_ranked_pairs[0] > current_hand_pairs[0]) result = Compare_Result.LOSE;\n// \t\t\t\t// else if (highest_ranked_pairs[0] < current_hand_pairs[0]) result = Compare_Result.WIN;\n// \t\t\t\t// else {\n// \t\t\t\t// \tif (highest_ranked_pairs[1] > current_hand_pairs[1]) result = Compare_Result.LOSE;\n// \t\t\t\t// \telse if (current_hand_pairs[1] < current_hand_pairs[1]) result = Compare_Result.WIN;\n// \t\t\t\t// \telse result = Compare_Result.TIE;\n// \t\t\t\t// }\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.FOUR_OF_KIND: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n// \t\t\t\telse {\n// \t\t\t\t\tif (highest_ranked_best_cards[4].value > current_hand_best_cards[4].value) result = Compare_Result.LOSE;\n// \t\t\t\t\telse if (highest_ranked_best_cards[4].value < current_hand_best_cards[4].value) result = Compare_Result.WIN;\n// \t\t\t\t\telse result = Compare_Result.TIE;\n// \t\t\t\t}\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.STRAIGHT_FLUSH: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n// \t\t\t\telse Compare_Result.TIE;\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t\tcase Hand_Rank.ROYAL_FLUSH: {\n// \t\t\t\tif (highest_ranked_best_cards[0].value > current_hand_best_cards[0].value) result = Compare_Result.LOSE;\n// \t\t\t\telse if (highest_ranked_best_cards[0].value < current_hand_best_cards[0].value) result = Compare_Result.WIN;\n// \t\t\t\telse Compare_Result.TIE;\n// \t\t\t\tbreak;\n// \t\t\t}\n// \t\t}\n// \t}\n\n// \treturn result;\n// };\n\nexport function find_hand_winner(_game: Game): Hand_Results {\n\n\t// let best_hand: Ranked_Hand = rankHand(_game.players[0], _game.community_cards); // do this to avoid unassigned var error, FIX??\n\n\tlet best_hands: Ranked_Hand[] = [];\n\n\tconst hand_result: Hand_Results = {\n\t\twinners: []\n\t};\n\n\t// get the hand ranks for each player\n\t// then compare it to the highest ranked hand in the current hand\n\t// and see if it is higher and if so set them as new winning player\n\t_game.players.forEach(player => {\n\t\tconst current_ranked_hand = rankHand(player, _game.community_cards);\n\t\tplayer.hand_rank = current_ranked_hand.rank;\n\t\tplayer.final_hand_cards = current_ranked_hand.hand;\n\n\t\tif (player.has_folded) {\n\n\t\t} else {\n\t\t\tif (best_hands.length == 0) {\n\t\t\t\tbest_hands.push(current_ranked_hand);\n\t\t\t} else {\n\t\t\t\tconst result: Compare_Result = compare_hands(current_ranked_hand, best_hands[0]);\n\t\t\n\t\t\t\tif (result == Compare_Result.WIN) {\n\t\t\t\t\tbest_hands = [];\n\t\t\t\t\tbest_hands.push(current_ranked_hand);\n\t\t\t\t} else if (result == Compare_Result.TIE) {\n\t\t\t\t\tbest_hands.push(current_ranked_hand);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t\t// find_five_used_cards(player);\n\t\t\n\t\tif (!_game.is_sim_game) {\n\t\t\tdisplayFinalHand(player);\n\t\t}\n\t});\n\n\tif (best_hands.length > 1) {\n\t\tfor (let hand of best_hands) {\n\t\t\t_game.hand_winners.push(hand.player);\n\t\t\thand_result.winners.push(hand.player);\n\t\t}\n\n\t\tif (!_game.is_sim_game) {\n\t\t\tlet winners_str = \"\";\n\t\t\tfor (let player of _game.hand_winners) {\n\t\t\t\twinners_str += ` ${player.name}`;\n\t\t\t}\n\t\t\tadd_log_msg(\"Tie Between\" + winners_str);\n\t\t\tlet winnerElem: Element | null = document.querySelector(\".winner\");\n\t\t\tif (winnerElem) {\n\t\t\t\twinnerElem.innerHTML = \"Tie Between\" + winners_str;\n\n\t\t\t\tlet winnings_per_player = _game.current_hand.pot / _game.hand_winners.length;\n\t\t\t\tfor (let player of _game.hand_winners) {\n\t\t\t\t\tplayer.money += winnings_per_player;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t_game.hand_winners.push(best_hands[0].player);\n\t\thand_result.winners.push(best_hands[0].player);\n\n\t\tif (!_game.is_sim_game) {\n\t\t\tadd_log_msg(\"Hand winner is \" + _game.hand_winners[0].name);\n\t\t\tlet winnerElem: Element | null = document.querySelector(\".winner\");\n\t\t\tif (winnerElem) {\n\t\t\t\twinnerElem.innerHTML = best_hands[0].player.name + \"wins the hand!\";\n\t\t\t\t// console.log(highestRankedHand);\n\t\t\t\t_game.hand_winners[0].money += _game.current_hand.pot;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn hand_result;\n};\n\nexport function clear_final_hand(player: Player) {\n\tconst player_elem = el(`.${player.name}`);\n\tconst final_hand_elem = player_elem.querySelector(':scope > .final_hand');\n\tconst final_hand_children = final_hand_elem.querySelectorAll(':scope > div');\n\t\n\tfinal_hand_children.forEach(child => {\n\t\tchild.innerHTML = \"\";\n\t})\n};\n\n\n\nfunction displayFinalHand(player: Player) {\n\n\t// at then end of a hand update the dom with all active players\n\t// final hands and ranks\n\n\tconst player_el = el(`.${player.name}`)\n\n\tconst hand_rank_el = child_el(player_el, \".hand_rank\");\n\thand_rank_el.innerHTML = \"Rank: \" + Hand_Rank[player.hand_rank];\n\n\tconst final_cards_el = child_el(player_el, \".final_hand_cards\");\n\tfor (let card of player.final_hand_cards) {\n\t\tlet imageElem = getCardImage(card.value, card.suit, true);\n\t\tfinal_cards_el.innerHTML += imageElem;\t\n\t}\n\n\tconst best_cards_el = child_el(player_el, \".best_cards\");\n\n\tfor (let card of player.best_cards) {\n\t\tlet imageElem = getCardImage(card.value, card.suit, true);\n\t\tbest_cards_el.innerHTML += imageElem;\t\n\t}\n\n\t// let playerElem = document.querySelector(\".\" + player.name);\n\t// if (playerElem) {\n\t// \tlet children = Array.from(playerElem.children);\n\t// \tchildren.forEach((child) => {\n\t// \t\tif (child.classList.contains(\"final_hand\")) {\n\t// \t\t\tlet finalHandElem = child;\n\t// \t\t\tlet finalHandElemChildren = Array.from(finalHandElem.children);\n\n\t// \t\t\tfinalHandElemChildren.forEach((elem, index) => {\n\t// \t\t\t\tif (index == 0) {\n\t// \t\t\t\t\t// set final hand player rank\n\t// \t\t\t\t\telem.innerHTML = \"RANK: \" + player.hand_rank;\n\t// \t\t\t\t} else if (index == 1) {\n\t// \t\t\t\t\tlet finalHandCardsElem = elem;\n\n\t// \t\t\t\t\t// set final player hand, including community cards\n\t// \t\t\t\t\tplayer.final_hand_cards.forEach((card) => {\n\t// \t\t\t\t\t\tlet imageElem = getCardImage(elem, card.value, card.suit, true);\n\t// \t\t\t\t\t\tfinalHandCardsElem.innerHTML = finalHandCardsElem.innerHTML + imageElem;\n\t// \t\t\t\t\t});\n\t// \t\t\t\t}\n\t// \t\t\t});\n\t// \t\t}\n\t// \t});\n\t// }\n};\n\nfunction toggle_end_of_hand_el() {\n\tel(\".end_of_hand\").classList.toggle(\"end_of_hand_hide\");\n};\n\nexport function blinds() {\n\tconsole.log(\"doing blinds\")\n\tconst bb_player = game.round_order[game.round_order.length - 1];\n\tconst sb_player = game.round_order[game.round_order.length - 2];\n\tconst dealer_player = game.round_order[game.round_order.length - 3];\n\n\tchild_el(el(`.${dealer_player.name}`), \".player_name\").innerHTML = dealer_player.name + \" -- DEALER\";\n\tchild_el(el(`.${bb_player.name}`), \".player_name\").innerHTML = bb_player.name + \" -- BB\";\n\tchild_el(el(`.${sb_player.name}`), \".player_name\").innerHTML = sb_player.name + \" -- SB\";\n\n\tadd_money_to_pot(sb_player, game.blinds.small);\n\tadd_money_to_pot(bb_player, game.blinds.big);\n\n\tgame.current_hand.current_bet = game.blinds.big;\n\n\tupdate_player_ui();\n}\n\n\n\n\n// round_order[0] = dealer\n// round_order[1] = bb\n// round_order[2] = sm\n// round_order[3] = first to play\n\n// start w/ dealer_index\n// then add 3 to it to get first player in round to bet\nexport function create_round_order(dealer_index: number): void {\n\tlet first_player = dealer_index + 3;\n\tif (first_player > game.players.length - 1) {\n\t\tfirst_player -= game.players.length;\n\t}\n\t// console.log(`first_player_id: ${first_player}`);\n\n\tlet start = game.players.slice(first_player);\n\tlet end = game.players.slice(0, first_player);\n\tgame.round_order = start.concat(end);\n\n\tgame.round_current_player_index = 0;\n\tgame.active_player = game.players[first_player];\n\n\t// console.log(game.active_player)\n};\n\nfunction toggle_bet_options_el(): void {\n\tel(\".bet_options\").classList.toggle(\"bet_options_hide\");\n};\n\nfunction add_money_to_pot(player: Player, value: number) {\n\tplayer.money -= value;\n\tgame.current_hand.pot += value;\n\n\t\n\n\tplayer.amount_bet_this_round += value;\n\n\tel(\".pot\").innerHTML = `Pot: ${game.current_hand.pot}`; \n}\n\n\nfunction humanBet() {\n\tconst bet_elem = el(\".bet_amount\");\n\t\n\tlet bet_amount = parseInt(bet_elem.innerHTML);\n\n\tbet_amount -= game.current_hand.current_bet;\n\n\t// only accept the click if the betAmount is > 0 >= roundbetAmount\n\tif (bet_amount > 0 ) {\n\t\tplace_bet(game.human_player, bet_amount);\n\t\tend_turn(game.human_player, true);\n\t} else {\n\t\t//log('player tried to bet zero, or less than the roundBetAmount')\n\t}\n};\n\nexport function fold(player: Player) {\n\tplayer.has_folded = true;\n\t// game.players.splice(player.id);\n\tend_turn(player, false);\n};\n\nfunction checkValidBet(tempBetAmount: number) {\n\t// make sure the human player has entered a valid bet that is <= their money && >= minBet\n\n\tif (tempBetAmount <= game.players[0].money && tempBetAmount > game.current_hand.current_bet) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\nfunction setToMaxBet() {\n\t// the amount entered in betAmount was too high, setting to the max possible bet\n\t//log('setting to max bet');\n\n\tlet maxBet = game.players[0].money;\n};\n\nfunction setNewRoundOrderAfterBet(player: Player) {\n\t// //restart the round order starting at the bet makers index + 1\n\t// //find the next player and start a new round of betting w/ them\n\n\t// let nextPlayer = findNextPlayer();\n\t// // console.log(\"next_player: \" + nextPlayer.id)\n\t// // get their index and set it to the startingPlayerIndex\n\t// // this is used for the next round to determine where the betting should start\n\t// // we want betting to start on the last player to bet\n\n\t// let nextPlayerIndex = getPlayerRoundIndex(nextPlayer);\n\t// // game.round_start_player_index = nextPlayerIndex;\n\t// // game.active_player = nextPlayer;\n\n\t// // create the new round order\n\t// // createRoundOrder(nextPlayerIndex);\n\t// // game.active_player = game.round_order[0];\n\n\t// // since the current player has already bet we need to remove them from the end of the round\n\t// game.round_order = game.round_order.slice(0, game.round_order.length - 1);\n\n\t// start_turn(nextPlayer);\n\n\t// console.log(`round current player index: ${game.round_current_player_index}`)\n\t// debugger;\n\tlet first_player_id = player.id;\n\t// console.log(`first_player_id: ${first_player}`);\n\n\tlet start = game.players.slice(first_player_id);\n\tlet end = game.players.slice(0, first_player_id);\n\tgame.round_order = start.concat(end);\n\n\tgame.round_current_player_index = 0;\n\tgame.active_player = game.round_order[game.round_current_player_index];\n\tadd_log_msg(\"Changed round order after bet. Start of round is \" + game.round_order[game.round_current_player_index].name + \". End of round is\" + game.round_order[game.round_order.length - 1].name);\n};\n\nfunction getPlayerRoundIndex(player: Player): number {\n\t// find what round index a player has\n\tlet index = 0;\n\tfor (let i = 0; i < game.round_order.length; i++) {\n\t\tif (game.round_order[i].id == player.id) return i;\n\t}\n\n\treturn index;\n};\n\nexport function rankHand(player: Player, community_cards: Card[]): Ranked_Hand  {\n\tlet hand: Card[] = player.hand;\n\thand = hand.concat(community_cards);\n\n\tlet highestValueInHand: number = 0;\n\tlet handRank: Hand_Rank = Hand_Rank.HIGH_CARD;\n\t// let handRankText: string;\n\n\t// hands will be ranked as\n\t// highcard = 0, pair = 1, two pair = 2, three of kind = 3, straight = 4, flush = 5, fullhouse = 6,\n\t// four of kind = 7, straight flush = 8, royal flush = 9\n\n\t//isHighCard(hand); // is this needed???\n\n\n\tif (isPair(hand)) {\n\t\thandRank = Hand_Rank.PAIR;\n\t\t// handRankText = \"Pair\";\n\t}\n\n\tif (isTwoPair(hand)) {\n\t\thandRank = Hand_Rank.TWO_PAIR;\n\t\t// handRankText = \"Two Pair\";\n\t}\n\n\tif (isThreeOfKind(hand)) {\n\t\thandRank = Hand_Rank.THREE_OF_KIND;\n\t\t// handRankText = \"Three of a kind\";\n\t}\n\n\tif (isStraight(hand)) {\n\t\thandRank = Hand_Rank.STRAIGHT;\n\t\t// handRankText = \"Straight\";\n\t}\n\n\tif (get_flush_cards(hand)) {\n\t\thandRank = Hand_Rank.FLUSH;\n\t\t// handRankText = \"Flush\";\n\t}\n\n\tif (isFullHouse(hand)) {\n\t\thandRank = Hand_Rank.FULL_HOUSE;\n\t\t// handRankText = \"Full House\";\n\t}\n\n\tif (get_four_of_kind_cards(hand)) {\n\t\thandRank = Hand_Rank.FOUR_OF_KIND;\n\t\t// handRankText = \"Four of a kind\";\n\t}\n\n\tif (isStraighFlush(hand)) {\n\t\thandRank = Hand_Rank.STRAIGHT_FLUSH;\n\t\t// handRankText = \"Straight Flush\";\n\t}\n\n\tif (isRoyalFlush(hand)) {\n\t\thandRank = Hand_Rank.ROYAL_FLUSH;\n\t\t// handRankText = \"Royal Flush\";\n\t}\n\n\treturn {\n\t\trank: handRank,\n\t\tplayer: player,\n\t\thighest_value_in_hand: highestValueInHand,\n\t\thand: hand\n\t};\n};\n\nfunction isRoyalFlush(hand: Card[]): boolean {\n\thand = sort_cards(hand);\n\thand = removeDuplicateValues(hand);\n\n\tlet hasRoyalFlush = false;\n\t// check if hand has at least 5 cards\n\tconst suit: Suit = hand[0].suit;\n\tif (hand.length >= 5) {\n\t\t// check if highest card is an ace\n\t\tif (hand[0].value == 14) {\n\t\t\tif (hand[4].value == 10) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (let card of hand) {\n\t\t\tif (card.suit != suit) return false;\n\t\t}\n\t}\n\treturn false;\n};\n\nfunction isStraighFlush(hand: Card[]): boolean {\n\tif (get_straight_cards(hand) && get_flush_cards(hand)) return true;\n\treturn false;\n};\n\nfunction isFourOfKind(hand: Card[]): boolean {\n\thand.forEach((card, index) => {\n\t\t// for each card check how many other cards their are of this cardValue\n\t\tlet cardValue = card.value;\n\t\tlet numOfValue = 0;\n\n\t\t// check against every card in hand\n\t\thand.forEach((otherCard, otherIndex) => {\n\t\t\tif (index != otherIndex) { // ignore counting the same card when we loop over it\n\t\t\t\tif (cardValue == otherCard.value) {\n\t\t\t\t\tnumOfValue++;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (numOfValue >= 4) return true;\n\t});\n\n\treturn false;\n};\n\nfunction isFullHouse(hand: Card[]): boolean {\n\tif (isPair(hand) && isThreeOfKind(hand)) {\n\n\t\t// check to make sure we have at least two seperate pairs\n\t\t// otherwise the three of a kind could just be the same cards as the pair + the 3rd card\n\t\tconst pairs = find_pairs(hand);\n\t\tif (pairs.length >= 2) return true;\n\t} \n\t\n\treturn false;\n};\n\nfunction isFlush(hand: Card[]): boolean {\n\tlet count: number = 0;\n\tlet suit: Suit | null = null;\n\tfor (let card of hand) {\n\t\tif (card.suit == suit) count++;\n\t\telse {\n\t\t\tsuit = card.suit;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\n\tif (count >= 5) return true;\n\treturn false;\n};\n\nfunction isStraight(hand: Card[]): boolean {\n\thand = sort_cards(hand);\n\thand = removeDuplicateValues(hand);\n\n\tif (hand.length < 5) return false;\n\n\tlet numMatches = 0;\n\tfor (let i = 1; i < hand.length; i++) {\n\t\tlet card = hand[i];\n\t\tlet prevCard = hand[i - 1];\n\n\t\tif (card.value != prevCard.value - 1) {\n\t\t\tnumMatches = 0; // reset to restart the count for a straight\n\t\t} \n\t\telse numMatches++;\n\n\t\tif (numMatches == 4) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isThreeOfKind(hand: Card[]): boolean {\n\tfor (let card of hand) {\n\t\tlet count = 1;\n\n\t\tfor (let other_card of hand) {\n\t\t\tif (card.id != other_card.id && card.value == other_card.value) count++;\n\t\t}\n\n\t\tif (count == 3) return true;\n\t}\n\n\treturn false;\n};\n\nfunction isTwoPair(hand: Card[]) {\n\tlet pairs = find_pairs(hand);\n\n\tif (pairs.length == 2) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\nfunction isPair(hand: Card[]): boolean {\n\tif (find_pairs(hand).length > 0) return true;\n\treturn false;\n};\n\n\nexport function find_pairs(hand: Card[]): number[] {\n\tlet pairs: number[] = [];\n\n\thand.forEach((card, index) => {\n\t\thand.forEach((otherCard, otherIndex) => {\n\t\t\tif (card.value == otherCard.value && index != otherIndex) {\n\t\t\t\t// make sure we haven't already found this match\n\t\t\t\tif (pairs.length == 0) {\n\t\t\t\t\tpairs.push(card.value);\n\t\t\t\t} else {\n\t\t\t\t\tlet match = false;\n\t\t\t\t\tpairs.forEach((pairCard) => {\n\t\t\t\t\t\tif (card.value == pairCard) {\n\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!match) {\n\t\t\t\t\t\tpairs.push(card.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\treturn pairs;\n};\n\n\nexport function sort_cards(hand: Card[]): Card[] {\n\treturn hand.sort(function (a, b) { return b.value - a.value }); // sort hand by card values, highest to lowest\n};\n\nexport function removeDuplicateValues(hand: Card[]): Card[] {\n\t// remove any duplicate cards with same values in hand\n\tconst new_hand: Card[] = [];\n\tfor (let card of hand) {\n\t\tif (new_hand.length == 0) new_hand.push(card);\n\t\telse {\n\t\t\tlet is_dupe = false;\n\t\t\tfor (let other_card of hand) {\n\t\t\t\tif (card.value == other_card.value && card.id != other_card.id) is_dupe = true;\n\t\t\t}\n\n\t\t\tif (!is_dupe) new_hand.push(card);\n\t\t}\n\t}\n\n\treturn new_hand;\n};\n\nexport function get_cards_with_value(hand: Card[], value: Card_Type): Card[] {\n\tconst cards: Card[] = [];\n\tfor (let card of hand) {\n\t\tif (card.value == value) cards.push(card);\n\t}\n\n\treturn cards;\n}\n\n\n\n\n\n\nexport function get_flush_cards(hand: Card[]): Card[] | false {\t\n\tfor (let card of hand) {\n\t\tlet temp_cards: Card[] = [];\n\t\tlet suit: Suit = card.suit;\n\n\t\tfor (let other_card of hand) {\n\t\t\tif (suit == other_card.suit) {\n\t\t\t\ttemp_cards.push(other_card);\n\t\t\t\tif (temp_cards.length == 5) return temp_cards;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// function get_full_house_cards(hand: Card[]): Card[] | false {\n// \tlet three_of_kind: Card[] = [];\n// \tlet pair: Card[] = [];\n\n\t\n// \tfor (let card of hand) {\n// \t\tconst temp_cards: Card[] = [];\n// \t\tfor (let other_card of hand) {\n// \t\t\tif (other_card.value == card.value) temp_cards.push(other_card);\n// \t\t}\n\t\n// \t\tif (temp_cards.length == 3) {\n// \t\t\t// check to to see if there are two sets of 3 (this is still a 7 card hand)\n// \t\t\t// if so then check to see which on to use as the pair\n// \t\t\tif (three_of_kind.length == 0) {\n// \t\t\t\tthree_of_kind = temp_cards;\n// \t\t\t} else {\n// \t\t\t\tif (temp_cards[0].value > three_of_kind[0].value) {\n\n// \t\t\t\t\tpair = three_of_kind.slice(0, 2);\n// \t\t\t\t\tthree_of_kind = temp_cards;\n// \t\t\t\t} else {\n// \t\t\t\t\tpair = temp_cards.slice(0, 2);\n// \t\t\t\t}\n// \t\t\t}\n// \t\t} else if (temp_cards.length == 2) {\n// \t\t\tpair = temp_cards;\n// \t\t}\n\n// \t\t// if (temp_cards.length == 3) three_of_kind = temp_cards;\n// \t\t// else if (temp_cards.length == 2) pair = temp_cards;\n// \t}\n\n\t\n\t\n// \tconsole.assert(three_of_kind.length == 3);\n// \tconsole.assert(pair.length == 2);\n\n// \t// if (three_of_kind.length != 3) {\n// \t// \tconsole.log(\"three of kind is not == to 3\");\n// \t// \tconsole.log(three_of_kind)\n// \t// }\n// \t// if (pair.length != 2) {\n// \t// \tconsole.log(\"pair is not == to 2\");\n// \t// \tconsole.log(pair)\n// \t// }\n\n// \tif (three_of_kind.length == 3 && pair.length == 2) return three_of_kind.concat(pair);\n\n// \treturn false;\n// }\n\nexport function get_four_of_kind_cards(hand: Card[]): Card[] | false {\n\tfor (let card of hand) {\n\t\tlet temp_cards: Card[] = [];\n\n\t\tfor (let other_card of hand) {\n\t\t\tif (card.value == other_card.value) temp_cards.push(other_card);\n\t\t\t\n\t\t\tif (temp_cards.length == 4) return temp_cards;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// function areWeTestingWithJest() {\n//     return process.env.JEST_WORKER_ID !== undefined;\n// }\n\nif (typeof jest !== 'undefined') {\n\tconsole.log(\"jest\")\n} else {\n\twindow.addEventListener(\"load\", function () {\n\t\tconsole.log(\"not jest\")\n\t\tinit(); // start\n\t});\n}"],
  "mappings": "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",
  "names": ["Suit", "Hand_Rank", "Card_Type", "game"]
}
